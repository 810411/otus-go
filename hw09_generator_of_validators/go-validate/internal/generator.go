package internal

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

var (
	tmpl = `
func ({{ .VarName }} {{ .Name }}) Validate() ([]ValidationError, error) {
	vErrs := []ValidationError{}
	{{ range .Fields }}
	{{- if (eq .Type "int")}}
	{{ template "intTmpl" . }}
	{{- end }}
	{{- if (eq .Type "string")}}
	{{ template "strTmpl" . }}
	{{- end }}
	{{- if (eq .Type "[]int")}}
	for i, _ := range {{ .VarName }}.{{ .Name }} {
		{{ $new := field . }}
		{{ template "intTmpl" $new }}
	}
	{{- end }}
	{{- if (eq .Type "[]string")}}
	for i, _ := range {{ .VarName }}.{{ .Name }} {
		{{ $new := field . }}
		{{ template "strTmpl" $new }}
	}
	{{- end }}
	{{ end }}
	return vErrs, nil
}
`
	intTmpl = `
	{{- if (eq .VType "min")}}
	if {{ .VarName }}.{{.Name}} < {{.VValue}} {
		vErrs = append(vErrs, ValidationError{
			Field: "{{.Name}}",
			Err: fmt.Errorf("less than min"),
	  	})
	}
	{{- end }}
	{{- if (eq .VType "max")}}
	if {{ .VarName }}.{{.Name}} > {{.VValue}} {
		vErrs = append(vErrs, ValidationError{
			Field: "{{.Name}}",
			Err: fmt.Errorf("more than max"),
	  	})
	}
	{{- end }}
	{{- if (eq .VType "in")}}
	arr := []int{ {{.VValue}} }
	isErr := true
	for _, i := range arr {
		if {{ .VarName }}.{{.Name}} == i {
			isErr = false
			break
	  	}
	}
	if isErr {
	  	vErrs = append(vErrs, ValidationError{
			Field: "{{.Name}}",
			Err: fmt.Errorf("not allowed value"),
	  	})
	}
	{{- end }}
`
	strTmpl = `
	{{- if (eq .VType "len")}}
	if len({{.VarName}}.{{.Name}}) != {{.VValue}} {
	  	vErrs = append(vErrs, ValidationError{
			Field: "{{.Name}}",
			Err: fmt.Errorf("wrong length"),
	  	})
	}
	{{- end }}
	{{- if (eq .VType "regexp")}}
	matched, err := regexp.MatchString("{{.VValue}}", {{.VarName}}.{{.Name}})
	if err != nil {
	  	return vErrs, fmt.Errorf("wrong regexp")
	}
	if !matched {
	  	vErrs = append(vErrs, ValidationError{
			Field: "{{.Name}}",
			Err: fmt.Errorf("does not match regexp"),
	  	})
	}
	{{- end }}
	{{- if (eq .VType "in")}}
	arr := []string{ {{.VValue}} }
	isErr := true
	for _, i := range arr {
	  	if string({{.VarName}}.{{.Name}}) == i {
			isErr = false
			break
	  	}
	}
	if isErr {
	  	vErrs = append(vErrs, ValidationError{
			Field: "{{.Name}}",
			Err: fmt.Errorf("not allowed value"),
	  	})
	}
	{{- end }}
`
)

func Generate(filepath string, packName string, structVArr []StructV) error {
	t, err := template.New("validation").Funcs(template.FuncMap{
		"field": func(field FieldV) FieldV {
			field.Type = strings.TrimPrefix(field.Type, "[]")
			field.Name += "[i]"
			return field
		},
	}).Parse(tmpl)
	if err != nil {
		return err
	}

	_, err = t.New("intTmpl").Parse(intTmpl)
	if err != nil {
		return err
	}

	_, err = t.New("strTmpl").Parse(strTmpl)
	if err != nil {
		return err
	}

	file, err := os.Create(strings.TrimSuffix(filepath, ".go") + "_validation_generated.go")
	if err != nil {
		return err
	}
	defer file.Close()

	fileHead := "// Code generated by go-validate. DO NOT EDIT."
	fileHead += fmt.Sprintf("\npackage %s", packName)
	fileHead += `

import (
	"fmt"
	"regexp"
)

type ValidationError struct {
	Field string
	Err   error
}

`
	_, err = file.Write([]byte(fileHead))
	if err != nil {
		return err
	}

	for _, v := range structVArr {
		err = t.ExecuteTemplate(file, "validation", v)
		if err != nil {
			return err
		}
	}

	return nil
}
